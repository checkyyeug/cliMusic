# XPU 设计审查报告 - 严重问题清单

## 阅读说明

经过仔细审阅设计文档，我尝试理解每处设计的原始意图。以下是我认为**真正严重或需要优先处理**的问题，按严重程度排序。

---

## 严重问题（P0 - 必须处理）

### 1. 状态同步问题：CLI 与 API 状态不一致

**问题描述**：

设计文档中，CLI 模块可以独立运行（管道模式），也可以通过 Daemon 调度运行。这两种模式下，状态管理的行为可能不一致。

```
可能出现的场景：
1. 用户通过 CLI xpuQueue add ~/song1.flac 添加歌曲
2. 通过 MCP xpu_queue_add 添加 song2
3. 通过 REST API GET /queue 查询队列

问题：不同入口可能看到不同的状态，AI Agent 可能基于过时状态做出错误决策
```

**原设计的好处**：
- CLI 模块设计为无状态，可以独立使用，遵循 Unix 哲学
- Daemon 维护全局状态，实现状态共享

**为什么必须处理**：
- 设计文档未明确状态同步机制
- AI Agent 需要准确的状态才能正确决策
- 用户体验混乱，不同入口看到不同结果

**建议处理方式**：
- 明确规范：CLI 操作后必须同步状态到 Daemon
- 实现 WebSocket 状态推送，确保各入口状态一致
- 或者强制 CLI 操作也通过 Daemon 路由

---

### 2. 错误处理机制缺失

**问题描述**：

设计文档在 3.1 节提到"错误码：标准化的退出码"，但未定义具体内容。

```
缺失内容：
- 错误码具体定义（哪些数字代表什么错误）
- 错误消息格式（JSON 错误响应）
- 管道中错误如何传播
- 错误恢复策略
```

**原设计的好处**：
- 模块崩溃不影响其他模块（2.2 节容错设计）
- 每个模块独立处理错误

**为什么必须处理**：
- 管道场景下，错误信息丢失或无法定位
- AI Agent 收到错误后无法理解原因
- 调试困难

**建议处理方式**：
- 定义完整的错误码体系（系统错误、参数错误、资源错误等）
- 规范错误消息 JSON 格式
- 实现错误传播机制，保留错误上下文

---

### 3. 模块职责重叠：xpuMeta vs xpuSearch

**问题描述**：

```
设计文档 4.3：xpuMeta 搜索功能
$ xpuMeta search "artist:Queen" --in ~/Music

设计文档 4.9：xpuSearch 搜索功能
$ xpuSearch --query "artist:Queen"
```

**原设计的好处**：
- xpuMeta 侧重"元数据操作+简单搜索"
- xpuSearch 侧重"全库高级搜索"
- 查询语法不同，适应不同场景

**为什么必须处理**：
- 用户体验混乱，不知道该用哪个
- 代码维护成本高
- 两个模块的查询语法不一致

**建议处理方式**：
- 明确分工，一个负责简单操作，一个负责高级搜索
- 或者合并为单一搜索模块，统一查询语法

---

## 重要问题（P1 - 建议优先处理）

### 4. 外部服务依赖 - 离线场景未定义

**问题描述**：

```
xpuFingerprint：可查询 AcousticBrainz 在线数据库
xpuQuery：直接查询 MusicBrainz/AcousticBrainz
xpuClassify：ML 分类器可能需要在线更新
```

**原设计的好处**：
- 在线数据库提供更准确的音乐信息
- 减少本地计算负担

**为什么建议优先处理**：
- 设计文档未定义离线场景行为
- 用户不知道什么时候会失败
- 没有本地回退机制

**建议处理方式**：
- 明确规范：离线时返回特定错误码
- 建议本地缓存查询结果
- xpuQuery 添加 `--offline` 参数明确行为

---

### 5. REST API 缺少分页机制

**问题描述**：

设计文档 6.1 节的 `/queue` 端点返回完整队列，无分页。

```
问题：
- 队列有 1000 首歌曲时，GET /queue 返回巨大的响应
- 客户端难以处理
- WebSocket 事件推送时数据量可能过大
```

**原设计的好处**：
- 简单场景下无需分页

**为什么建议优先处理**：
- 实际使用中队列可能很大
- 性能问题

**建议处理方式**：
- 添加分页参数（page, limit）
- 添加 cursor 分页支持
- 队列事件推送改为增量更新

---

### 6. 资源访问控制缺失

**问题描述**：

```
当前设计假设：单用户本地使用

问题：
- REST API 和 MCP 接口暴露后存在安全风险
- 远程调用场景（设计文档 7.3 服务发现提到远程访问）
- 路径遍历攻击风险
```

**原设计的好处**：
- 简单场景下无需复杂权限管理
- 单用户本地使用无需访问控制

**为什么建议优先处理**：
- REST API 和 MCP 接口发布后，任何人都可以调用
- 存在安全风险

**建议处理方式**：
- 添加基础认证机制（API Key）
- 实现路径验证，防止越权访问
- 添加可选的多用户支持

---

## 需关注问题（P2 - 可后续处理）

### 7. 缓存系统碎片化

**问题描述**：

| 模块 | 缓存类型 | 存储位置 | 复用情况 |
|-----|---------|---------|---------|
| xpuIn2Wav | FFT 缓存 | ~/.cache/xpu/fft/ | 被其他模块复用 |
| xpuVisualize | 可视化缓存 | ~/.cache/xpu/visualize/ | 独立 |
| xpuFingerprint | 指纹缓存 | ? | 独立 |

**原设计的好处**：
- xpuIn2Wav 的 FFT 缓存设计很好，避免重复计算
- 每个模块管理自己的缓存，保持模块独立性

**为什么需关注**：
- FFT 缓存和可视化缓存可能存储重复数据
- 缓存可能无限增长耗尽磁盘

**建议处理方式**：
- 增强 xpuCache 模块作为统一缓存管理层
- 实现缓存自动清理策略

---

### 8. 控制管道细节缺失

**问题描述**：

```
xpuPlay < audio_data > control_pipe
xpuPlayCtrl pause < control_pipe

缺失细节：
- 控制管道如何命名？
- 多实例运行时是否冲突？
- 控制命令格式是什么？
- 管道断裂时如何检测？
```

**原设计的好处**：
- Unix 管道设计简单有效
- 保持 xpuPlay 和 xpuPlayCtrl 分离

**为什么需关注**：
- 实现时需要明确这些细节
- 多实例场景可能出问题

---

## 总结

| 优先级 | 问题 | 建议处理时机 |
|-------|-----|------------|
| P0 | 状态同步问题 | 设计阶段 |
| P0 | 错误处理机制缺失 | 实现前 |
| P0 | 模块职责重叠 | 设计阶段 |
| P1 | 外部服务依赖离线未定义 | 下一版本 |
| P1 | REST API 缺少分页 | 下一版本 |
| P1 | 资源访问控制缺失 | API 发布前 |
| P2 | 缓存系统碎片化 | 后续迭代 |
| P2 | 控制管道细节缺失 | 实现时 |

**结论**：设计文档整体质量较高，模块化架构清晰。最需要补充的是：状态同步机制、错误处理规范、模块职责划分、离线行为定义。